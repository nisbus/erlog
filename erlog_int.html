<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module erlog_int</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module erlog_int</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Basic interpreter of a Prolog sub-set.
<p>Copyright © (c) 2009 Robert Virding. All rights reserved.</p>

<p><b>Authors:</b> Robert Virding.</p>

<h2><a name="description">Description</a></h2><p>Basic interpreter of a Prolog sub-set.</p>
  
   <p>This is the basic Prolog interpreter.   
The internal data structures used are very direct and basic:</p>
  
   <ul>
   <li>Structures	- {Functor,arg1, Arg2,...} where Functor is an atom</li>
   <li>Variables	- {Name} where Name is an atom or integer</li>
   <li>Lists	- Erlang lists</li>
   <li>Atomic	- Erlang constants</li>
  </ul>
  
  <p>
   There is no problem with the representation of variables as Prolog
   functors of arity 0 are atoms. This representation is much easier
   to test for, and create new variables with than using funny atom
   names like '$1' (yuch!), and we need LOTS of variables.
  </p>
  
  <p>
   All information about the state of an evaluation is held in the
   variables:
  </p>
  
   <p>[CurrentGoal,] NextGoal, ChoicePoints, Bindings, VarNum, Database</p>
  
   <p>Proving a goal succeeds when we have reached the end of the goal   
list, i.e. NextGoal is empty (true). Proving goal fails when there   
are no more choice points left to backtrack into. The evaluation   
is completely flat as all back track information is held in   
ChoicePoints. Choice points are added going forwards and removed   
by backtracking and cuts.</p>
  
   <p>Internal goals all have the format {{Name},...} as this is an   
illegal Erlog structure which can never be generated in (legal)   
code.</p>
  
   <p>Proving a top-level goal will return:</p>
  
   <p>{succeed,ChoicePoints,Bindings,VarNum,Database} - the       
goal succeeded and these are the       
choicepoints/bindings/varnum/database to continue with.</p>
  
   <p>{fail,Database} - the goal failed and this is the current database.</p>
  
   <p>When a goal has succeeded back tracking is initiated by calling   
fail(ChoicePoints, Database) which has the same return values as   
proving the goal.</p>
  
   <p>When the interpreter detects an error it builds an error term</p>
  
  	<p>{erlog_error,ErrorDescriptor,Database}</p>
  
   <p>and throws it. The ErrorDescriptor is a valid Erlog term.</p>
  
  <h4><a name="Database">Database</a></h4>
  
   <p>We use a dictionary for the database. All data for a procedure are   
kept in the database with the functor as key. Interpreted clauses   
are kept in a list, each clause has a unique (for that functor)   
tag. Functions which traverse clauses, clause/retract/goals, get   
the whole list to use. Any database operations can they be done   
directly on the database. Retract uses the tag to remove the   
correct clause. This preserves the logical database view. It is   
possible to use ETS instead if a dictionary, define macro ETS, but   
the logical database view makes it difficult to directly use ETS   
efficiently.</p>
  
  <h4><a name="Interpreted_Code">Interpreted Code</a></h4>
  
   <p>Code, interpreted clause bodies, are not stored directly as Erlog   
terms. Before being added to the database they are checked that   
they are well-formed, control structures are recognised, cuts   
augmented with status and sequences of conjunctions are converted   
to lists. When code is used a new instance is made with fresh   
variables, correct cut labels, and bodies directly linked to   
following code to remove the need of later appending.</p>
  
   <p>The following functions convert code:</p>
  
  <ul>
   <li>well_form_body/4 - converts an Erlog term to database code body
       format checking that it is well formed.</li>
   <li>well_form_goal/4 - converts an Erlog term directly to a code body
       checking that it is well formed.</li>
   <li>unify_head/4 - unify a goal directly with head without creating a
       new instance of the head. Saves creating local variables and
       MANY bindings. This is a BIG WIN!</li>
   <li>body_instance/5 - creates a new code body instance from the
       database format.</li>
   <li>body_term/3 - creates a copy of a body as a legal Erlog term.</li>
  </ul>
   <h4><a name="Choicepoints/Cuts">Choicepoints/Cuts</a></h4>
  
   <p>Choicepoints and cuts are kept on the same stack/list. There are   
different types of cps depending on their context. Failure pops   
the first cp off the stack, passing over cuts and resumes   
execution from that cp. A cut has a label and a flag indicating if   
this is the last cut with this label. Cut steps over cps/cuts   
until a cut the same label is reached and execution is resumed   
with that stack. Unless this is the last cut with a label a new   
cut is pushed on the stack. For efficiency some cps also act as   
cuts.</p>
  
   <p>It is possible to reuse cut labels for different markers as long   
the areas the cuts are valid don't overlap, though one may be   
contained within the other, and the cuts correctly indicate when   
they are the last cut. This is used for -&gt;; and once/1 where we   
KNOW the last cut of the internal section.</p>
  
   It would be better if the cut marker was the actual cps/cut stack
   to go back to but this would entail a more interactive
   body_instance.
<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#abolish_clauses-2">abolish_clauses/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#add_binding-3">add_binding/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#add_compiled_proc-4">add_compiled_proc/4</a></td><td></td></tr>
<tr><td valign="top"><a href="#asserta_clause-2">asserta_clause/2</a></td><td>Assert a clause into the database first checking that it is well
  formed.</td></tr>
<tr><td valign="top"><a href="#assertz_clause-2">assertz_clause/2</a></td><td>assertz_clause(Head, Body, Database) -&gt; NewDatabase.</td></tr>
<tr><td valign="top"><a href="#built_in_db-0">built_in_db/0</a></td><td>Create an initial clause database containing the built-in
  predicates and predefined library predicates.</td></tr>
<tr><td valign="top"><a href="#dderef-2">dderef/2</a></td><td>Do a deep dereference.</td></tr>
<tr><td valign="top"><a href="#dderef_list-2">dderef_list/2</a></td><td> Dereference all variables to any depth but check that the
   top-level is a list.</td></tr>
<tr><td valign="top"><a href="#deref-2">deref/2</a></td><td>Dereference a variable, else just return the term.</td></tr>
<tr><td valign="top"><a href="#expand_term-1">expand_term/1</a></td><td>Handle DCG expansion.</td></tr>
<tr><td valign="top"><a href="#fail-2">fail/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#functor-1">functor/1</a></td><td>Add Head as a compiled procedure with code in Module:Function.</td></tr>
<tr><td valign="top"><a href="#new_bindings-0">new_bindings/0</a></td><td>Bindings are kept in a dict where the key is the variable name.</td></tr>
<tr><td valign="top"><a href="#prove_body-5">prove_body/5</a></td><td>Prove the goals in a body.</td></tr>
<tr><td valign="top"><a href="#prove_goal-2">prove_goal/2</a></td><td>This is the main entry point into the interpreter.</td></tr>
<tr><td valign="top"><a href="#unify-3">unify/3</a></td><td>Unify two terms with a set of bindings.</td></tr>
<tr><td valign="top"><a href="#unify_prove_body-7">unify_prove_body/7</a></td><td>Unify Term1 = Term2, on success prove body Next else fail.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="abolish_clauses-2">abolish_clauses/2</a></h3>
<div class="spec">
<p><tt>abolish_clauses(Func::Functor, Db::Database) -&gt; NewDatabase</tt></p>
</div>

<h3 class="function"><a name="add_binding-3">add_binding/3</a></h3>
<div class="spec">
<p><tt>add_binding(X1, Val, Bs0) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="add_compiled_proc-4">add_compiled_proc/4</a></h3>
<div class="spec">
<p><tt>add_compiled_proc(H, M, F, Db) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="asserta_clause-2">asserta_clause/2</a></h3>
<div class="spec">
<p><tt>asserta_clause(H::Clause, Db::Database) -&gt; NewDatabase</tt></p>
</div><p>Assert a clause into the database first checking that it is well
  formed.</p>

<h3 class="function"><a name="assertz_clause-2">assertz_clause/2</a></h3>
<div class="spec">
<p><tt>assertz_clause(H::Clause, Db::Database) -&gt; NewDatabase</tt></p>
</div><p>assertz_clause(Head, Body, Database) -&gt; NewDatabase.
  Assert a clause into the database first checking that it is well
  formed.</p>

<h3 class="function"><a name="built_in_db-0">built_in_db/0</a></h3>
<div class="spec">
<p><tt>built_in_db() -&gt; Database</tt></p>
</div><p>Create an initial clause database containing the built-in
  predicates and predefined library predicates.</p>

<h3 class="function"><a name="dderef-2">dderef/2</a></h3>
<div class="spec">
<p><tt>dderef(A::Term, Bs::Bindings) -&gt; Term</tt></p>
</div><p>Do a deep dereference. Completely dereference all the variables
  occuring in a term, even those occuring in a variables value.</p>

<h3 class="function"><a name="dderef_list-2">dderef_list/2</a></h3>
<div class="spec">
<p><tt>dderef_list(T::List, Bs::Bindings) -&gt; List</tt></p>
</div><p> Dereference all variables to any depth but check that the
   top-level is a list.</p>

<h3 class="function"><a name="deref-2">deref/2</a></h3>
<div class="spec">
<p><tt>deref(T0::Term, Bs::Bindings) -&gt; Term</tt></p>
</div><p>Dereference a variable, else just return the term.</p>

<h3 class="function"><a name="expand_term-1">expand_term/1</a></h3>
<div class="spec">
<p><tt>expand_term(Term) -&gt; {ExpTerm}</tt></p>
</div><p>Handle DCG expansion. We do NOT work backwards.</p>

<h3 class="function"><a name="fail-2">fail/2</a></h3>
<div class="spec">
<p><tt>fail(Cps::ChoicePoints, Db::Database) -&gt; {fail, Database}</tt></p>
</div>

<h3 class="function"><a name="functor-1">functor/1</a></h3>
<div class="spec">
<p><tt>functor(T::Goal) -&gt; {Name, Arity}</tt></p>
</div><p>Add Head as a compiled procedure with code in Module:Function. No
  checking.
  add_compiled_proc(Head, Module, Function, Database) -&gt; NewDatabase</p>

<h3 class="function"><a name="new_bindings-0">new_bindings/0</a></h3>
<div class="spec">
<p><tt>new_bindings() -&gt; any()</tt></p>
</div><p>Bindings are kept in a dict where the key is the variable name.</p>

<h3 class="function"><a name="prove_body-5">prove_body/5</a></h3>
<div class="spec">
<p><tt>prove_body(Gs::Body, Cps::ChoicePoints, Bs0::Bindings, Vn0::VarNum, Db0::Database) -&gt; {succeed, ChoicePoints, NewBindings, NewVarNum, NewDatabase}</tt></p>
</div><p>Prove the goals in a body. Remove the first goal and try to prove
  it. Return when there are no more goals. This is how proving a
  goal/body succeeds.</p>

<h3 class="function"><a name="prove_goal-2">prove_goal/2</a></h3>
<div class="spec">
<p><tt>prove_goal(Goal0::Goal, Db::Database) -&gt; Succeed | Fail</tt></p>
</div><p>This is the main entry point into the interpreter. Check that
  everything is consistent then prove the goal as a call.</p>

<h3 class="function"><a name="unify-3">unify/3</a></h3>
<div class="spec">
<p><tt>unify(T10::Term, T20::Term, Bs0::Bindings) -&gt; {succeed, NewBindings} | fail</tt></p>
</div><p>Unify two terms with a set of bindings.</p>

<h3 class="function"><a name="unify_prove_body-7">unify_prove_body/7</a></h3>
<div class="spec">
<p><tt>unify_prove_body(T1::Term1, T2::Term2, Next, Cps::ChoicePoints, Bs0::Bindings, Vn::VarNum, Db::Database) -&gt; void</tt></p>
</div><p>Unify Term1 = Term2, on success prove body Next else fail.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Jul 8 2011, 00:31:36.</i></p>
</body>
</html>
